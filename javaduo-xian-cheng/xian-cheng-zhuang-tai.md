![](/assets/线程状态.png)

* ##### **新建状态（New）：**
当线程对象对创建后，即进入了新建状态，如：Thread t = new MyThread\(\);

* ##### **就绪状态（Runnable）：**
当调用线程对象的start\(\)方法（t.start\(\);），线程即进入就绪状态。处于就绪状态的线程，只是说明此线程已经做好了准备，随时等待CPU调度执行，并不是说执行了t.start\(\)此线程立即就会执行；

* ##### **运行状态（Running）：**
当CPU开始调度处于就绪状态的线程时，此时线程才得以真正执行，即进入到运行状态。注：就绪状态是进入到运行状态的唯一入口，也就是说，线程要想进入运行状态执行，首先必须处于就绪状态中；Thread类中的yield方法可以让一个running状态的线程转入runnable（主动释放对CPU的控制）。

* ##### **阻塞状态（Blocked）：**
处于运行状态中的线程由于某种原因，暂时放弃对CPU的使用权，停止执行，此时进入阻塞状态，直到其进入到就绪状态，才 有机会再次被CPU调用以进入到运行状态。根据阻塞产生的原因不同，阻塞状态又可以分为三种：

 1. 等待阻塞：运行状态中的线程执行wait\(\)方法，使本线程进入到_**等待阻塞状态**_；

 2. 同步阻塞 -- 线程在获取synchronized同步锁失败\(因为锁被其它线程所占用\)，它会进入_**同步阻塞状态**_；

 3. 其他阻塞 -- 通过调用线程的**sleep\(\)或join\(\)或发出了I/O请求时**，线程会进入到阻塞状态。当sleep\(\)状态超时、join\(\)等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。

* ##### **死亡状态（Dead）：**
线程**执行完了**或者因**异常**退出了run\(\)方法，该线程结束生命周期。由于实际的业务需要，常常会遇到需要在特定时机终止某一线程的运行，使其进入到死亡状态。目前最通用的做法是设置一boolean型的变量，当条件满足时，使线程执行体快速执行完毕：t.stopThread\(\);
各种状态一目了然，值得一提的是"blocked"这个状态：  
线程在Running的过程中可能会遇到阻塞\(Blocked\)情况

 1. 调用join\(\)和sleep\(\)方法，sleep\(\)时间结束或被打断，join\(\)中断,IO完成都会回到Runnable状态，等待JVM的调度。
 2. 调用wait\(\)，使该线程处于等待池\(wait blocked pool\),直到notify\(\)/notifyAll\(\)，线程被唤醒被放到锁定池\(lock blocked pool \)，释放同步锁使线程回到可运行状态（Runnable）
 3. 对Running状态的线程加同步锁\(Synchronized\)使其进入\(lock blocked pool \),同步锁被释放进入可运行状态\(Runnable\)。



